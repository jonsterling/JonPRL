Operator welp : ().
[welp] =def= [unit].

Theorem test1 : [unit * unit * unit] {
  *{ intro ; auto }.
}.

||| Lemmas defined earlier in the development may be used later on using the 'lemma' tactic.
Theorem test1' : [unit * unit * unit] {
  lemma <test1>.
}.

||| Abstractions may be unfolded using the 'unfold' tactic.
Theorem test2 : [unit -> unit * welp] {
  unfold <welp>; auto
}.

Theorem test3 : [member(lam(x. x); unit -> unit)] {
  auto.
}.

Theorem test4 : [member(lam(x.<x,x>); void -> void)] {
  auto.
}.

Theorem test5 : [void -> unit * unit] {
  auto.
}.

Theorem test6 : [unit -> unit * unit * unit] {
  witness [lam(x. <x,x,x>)]; auto.
}.

Theorem test7 : [(void * unit) -> void] {
  auto;
  elim #1;
  auto.
}.

Theorem test8 : [member(void + void; U{i})] {
  auto
}.

Theorem test9 : [=(inl(<>); inl(<>); unit + void)] {
  auto
}.

Theorem test10 : [{A:U{i}} {B:U{i}} A + B -> B + A] {
  auto; elim #3; [intro #1, intro #0]; auto
}.

Theorem test11 : [=(decide(inl(<>); x.x; y.y); decide(inr(<>); x.x; y.y); unit)] {
  reduce; auto
}.

Theorem axiom-of-choice : [{A:U{i}} {B:U{i}} {Q : A -> B -> U{i}} (φ : (c:A) -> (b:B) * Q c b) (f : A -> B) * (a : A) Q a (f a)]
{
  auto; intro [lam(w. spread(φ w ; x.y.x))]; auto;
  elim #4 [a]; auto; reduce;
  hyp-subst ← #7 [h. Q a spread(h; x.y.x)]; auto;
  elim #6; reduce; auto
}.
