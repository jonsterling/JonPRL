Operator welp : ().
[welp] =def= [unit].

Theorem test1 : [prod(unit; _. prod(unit; _. unit))] {
  *{ intro ; auto }.
}.

||| Lemmas defined earlier in the development may be used later on using the 'lemma' tactic.
Theorem test1' : [prod(unit; _. prod(unit; _. unit))] {
  lemma <test1>.
}.

||| Abstractions may be unfolded using the 'unfold' tactic.
Theorem test2 : [fun(unit; _. prod(unit; _. welp))] {
  unfold <welp>; auto
}.

Theorem test3 : [member(lam(x. x); fun(unit; _. unit))] {
  auto.
}.

Theorem test4 : [member(lam(x.pair(x;x)); fun(void;_.void))] {
  auto.
}.

Theorem test5 : [fun(void; _. prod(unit; _.unit))] {
  auto.
}.

Theorem test6 : [fun(unit; _. prod(unit; _.unit))] {
  witness [lam(x. pair(x;x))]; auto.
}.

Theorem test7 : [fun(prod(void;_.unit); z. void)] {
  auto;
  elim #1;
  auto.
}.

Theorem test8 : [member(+(void; void); U{i})] {
  auto
}.

Theorem test9 : [=(inl(<>); inl(<>); +(unit; void))] {
  auto
}.

Theorem test10 : [isect(U{i}; A.
                  isect(U{i}; B.
                  fun(+(A; B); _. +(B; A))))] {
  auto; elim #3; [intro #1, intro #0]; auto
}.

Theorem test11 :
        [=(decide(inl(<>); x.x; y.y); decide(inr(<>); x.x; y.y); unit)] {
  reduce; auto
}.

Theorem axiom-of-choice : [isect(U{i}; A. isect(U{i}; B. isect(fun(A; _. fun(B; _. U{i})); Q. fun(fun(A; c. prod(B; b. ap(ap(Q;c);b))); φ. prod(fun(A; _.B); f. fun(A; a. ap(ap(Q;a);ap(f;a))))))))] {
  auto; intro [lam(w. spread(ap(φ;w); x.y.x))]; auto;
  elim #4 [a]; auto; reduce;
  hyp-subst ← #7 [h. ap(ap(Q;a); spread(h; x.y.x))]; auto;
  elim #6; reduce; auto
}.
