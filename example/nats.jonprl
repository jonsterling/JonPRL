Theorem natp-example : [nat] {
  witness [succ(zero)]; auto
}.

Theorem minus-one : [nat -> nat] {
  intro <n>; aux {auto};
  elim #1;
  [ witness [zero]
  , hypothesis #2
  ]; auto
}.

Theorem minus-one-test : [=(minus-one succ(succ(zero)); succ(zero); nat)] {
  unfold <minus-one>; reduce; auto
}.

Operator add : (0;0).
Infix -> 100 "N+" := add.
[M N+ N] =def= [natrec(M; N; _.n.succ(n))].

Tactic t {
  unfold <add>; auto 0; elim #1; reduce; auto 0.
}.

Theorem add-id-left : [{n:nat} =(zero N+ n; n; nat)] {
  t
}.

Theorem add-id-right : [{n:nat} =(n N+ zero; n; nat)] {
  t
}.

Theorem succ-right : [
  {n:nat} {m:nat} =(n N+ succ(m); succ(n N+ m); nat)
] {
  t
}.

Theorem add-commutes : [
  {n:nat} {m:nat} =(n N+ m; m N+ n; nat)
] {
  ||| Kick off the induction and do the boring computation thingies.
  t;

  ||| The base case immeidately follows from add-id-right
  focus 0 #{
    cut-lemma <add-id-right>; unfold <add>;
    symmetry;
    bhyp <add-id-right>; auto
  };

  ||| In order to prove this we first rewrite by succ-right from which our
  ||| result follows from reflexivity.
  cut-lemma <succ-right>; elim <succ-right> [m]; auto;
  unfold <add>; elim #6 [n']; auto;
  hyp-subst â†’ #8 [h.=(_; h; _)]; auto
}.
