Theorem natp-example : [nat] {
  witness [succ(zero)]; auto
}.

Theorem minus-one : [nat -> nat] {
  intro <n>; focus 1 #{ auto };
  elim #1;
  [ witness [zero]
  , hypothesis #2
  ]; auto
}.

Theorem minus-one-test : [=(minus-one succ(succ(zero)); succ(zero); nat)] {
  unfold <minus-one>; reduce; auto
}.

Operator add : (0;0).
[add(M; N)] =def= [natrec(M; N; _.n.succ(n))].

Tactic t {
  unfold <add>; auto 0; elim #1; reduce; auto 0.
}.

Theorem add-id-left : [{n:nat} =(add(zero; n); n; nat)] {
  t
}.

Theorem add-id-right : [{n:nat} =(add(n; zero); n; nat)] {
  t
}.

Theorem succ-right : [
  {n:nat} {m:nat} =(add(n; succ(m)); succ(add(n; m)); nat)
] {
  t
}.

Theorem add-commutes : [
  {n:nat} {m:nat} =(add(n; m); add(m; n); nat)
] {
  ||| Kick off the induction and do the boring computation thingies.
  t;

  ||| The base case immeidately follows from add-id-right
  focus 0 #{
    cut-lemma <add-id-right>;
    elim #3 [m]; auto; unfold <add>;
    hyp-subst → #4 [h.=(_;h;_)];
    auto
  };

  ||| In order to prove this we first rewrite by succ-right from which our
  ||| result follows from reflexivity.
  cut-lemma <succ-right>;
  elim #5 [m]; auto; elim #6 [n']; unfold <add>; auto;
  hyp-subst → #8 [h.=(_; h; _)];
  auto; eq-cd; auto
}.
