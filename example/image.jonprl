Theorem squash_wf : [ isect(U{i};t.member(squash(t);U{i})) ] {
  unfold <squash>; auto
}.

Theorem implies_squash : [ isect(U{i};t.t => squash(t)) ] {
  *{intro; focus 1 #{auto}};
  @{ [H:t |- _] => witness [lam(_.<>) H]};
  unfold <squash>; auto
}.

Theorem approx_id_refl_wf : [
  =(approx(lam(x.x);lam(x.x));approx(<>;<>);U{i})
] {
  unfold <member>; ext;
  cut-lemma <implies_squash>;
  elim #1 [iff(approx(lam(x.x); lam(x.x)); approx(<>; <>))];
  focus 0 #{ unfold <iff and implies>; auto };
  assert [iff(approx(lam(x.x); lam(x.x)); approx(<>; <>))];
  focus 1 #{elim #2 [H]; auto};
  unfold <iff and implies>; intro; intro; auto
}.

Theorem test_image_elim : [
  fun(nat;n.fun(nat;m.fun(squash(=(n;m;nat));x.=(x;x;squash(=(n;m;nat))) -> =(n;m;nat))))
] {
 intro;[ id, auto ];[id];
 intro;[ id, auto ];[id];
 intro;[ id, *{unfold <squash>;auto} ];[id];
 intro;[ id, *{unfold <squash>;auto} ];[id];
 unfold <squash>;
 elim <x> <e>;auto
}.
