Infix 2 "∈" := member.
Infix 100 "~" := ceq.
Postfix 10 "⇓" := has-value.
Prefix 50 "¬" := not.

Operator top : ().
[top] =def= [void => void].

Theorem top-wf : [top ∈ U{i}] {
  unfold <top>; auto
}.

Resource wf += { wf-lemma <top-wf> }.

Operator ν : (1).
[ν(x.F[x])] =def= [{n:nat} natrec(n; top; _.T.F[T])].

Theorem ν-wf : [{F:U{i} -> U{i}} ν(x.F x) ∈ U{i}] {
  auto; unfold <ν>; auto;
}.

||| generalized choice sequences
Operator choice-sequence : (0).
[choice-sequence(F)] =def= [ν(R.extension(F; R))].

Theorem choice-sequence-wf : [{F:container{i}} choice-sequence(F) ∈ U{i}] {
  auto; unfold <choice-sequence ν>; auto;
  eq-cd [U{i} -> U{i}]; auto
}.

Resource wf += { wf-lemma <choice-sequence-wf> }.

Operator hd : (0).
[hd(α)] =def= [dom(α)].

Operator tl : (0;0).
[tl(α; p)] =def= [proj(α; p)].

Theorem hd-wf : [{F:container{i}} {α:choice-sequence(F)} dom(α) ∈ dom(F)] {
  auto; intro @i; auto;
  unfold <choice-sequence ν hd>;
  elim #1; reduce;
  elim #4 [succ(zero)]; reduce; auto;
  prune { hyp-subst <- #6 [h.=(dom(h); dom(h); _)]; auto };
  @{ [H:extension(_;_) |- _] => elim <H>
   }; reduce; auto
}.

Resource wf += { wf-lemma <hd-wf> }.

Postfix 10 "♮" := neighborhoods.

||| Brouwer's container
Operator B : ().
[B] =def= [x:nat <: unit].

Theorem test : [<> ^ zero ^ succ(zero) ^ succ(succ(zero)) ∈ | B ♮|] {
  unfold <neighborhoods B>;
  *{ auto; reduce }
}.


Operator decidable : (0).
[decidable(P)] =def= [P + ¬ P].

Theorem implies-wf : [{P:U{i}} {Q:U{i}} implies(P; Q) ∈ U{i}] {
  unfold <implies>; auto
}.

Resource wf += { wf-lemma <implies-wf> }.

Theorem not-wf : [{P:U{i}} ¬ P ∈ U{i}] {
  unfold <not>; auto
}.

Resource wf += { wf-lemma <not-wf> }.

Theorem decidable-wf : [{P:U{i}} decidable(P) ∈ U{i}] {
  unfold <decidable>;
  auto
}.

Resource wf += { wf-lemma <decidable-wf> }.

Operator prefixes : (0;0).
Infix 10 "≼" := prefixes.

[u ≼ v] =def= [neigh-ind(v; neigh-ind(u; unit; _._._.void); w.e.ih.ih)].

Theorem prefixes-wf : [{F:container{i}} {u:|F ♮|} {v:|F ♮|} u ≼ v ∈ U{i}] {
  auto; unfold <prefixes neighborhoods>; reduce; auto
}.

Resource wf += { wf-lemma <prefixes-wf> }.

Operator spw-decidable : (0;0).
[spw-decidable(F; S)] =def= [(u:|F ♮|) decidable(S u)].

Operator spw-leaks-upwards : (0;0).
[spw-leaks-upwards(F; S)] =def= [(u:|F ♮|) S u -> (e:proj(F ♮; u) -> |F|) * S (u ^ r. e r)].

Operator spw-downward-closed : (0;0).
[spw-downward-closed(F; S)] =def= [(v:|F ♮|) (u:{u : |F ♮| | u ≼ v}) S u -> S v].

Theorem spw-decidable-wf : [{F:container{i}} {S:|F ♮| -> U{i}} spw-decidable(F; S) ∈ U{i}] {
  unfold <spw-decidable neighborhoods>; reduce; auto;
  elim #1; auto
}.

Theorem spw-leaks-upwards-wf : [{F:container{i}} {S:|F ♮| -> U{i}} spw-leaks-upwards(F; S) ∈ U{i}] {
  unfold <spw-leaks-upwards neighborhoods>; reduce; auto;
  elim #1; auto; reduce; auto;
  elim #5; reduce; auto
}.

Theorem spw-downward-closed-wf : [{F:container{i}} {S:|F ♮| -> U{i}} spw-downward-closed(F; S) ∈ U{i}] {
  auto; unfold <spw-downward-closed neighborhoods>; reduce; auto;
  cut-lemma <prefixes-wf>;
  elim #5 [F]; auto;
  unfold <member neighborhoods>; reduce;
  bhyp #6; auto;
}.

Resource wf += { wf-lemma <spw-decidable-wf> }.
Resource wf += { wf-lemma <spw-leaks-upwards-wf> }.
Resource wf += { wf-lemma <spw-downward-closed-wf> }.

||| I can't use the word "spread" (because that's the name of the recursor for
||| pairs), so I'll use the Dutch.

Operator spreidingswet : (0;0).
[spreidingswet(F; S)] =def= [
  spw-decidable(F; S)
    * spw-leaks-upwards(F; S)
    * spw-downward-closed(F; S)
    * S <>
].

Theorem spreidingswet-wf : [{F:container{i}} {S:|F ♮| -> U{i}} spreidingswet(F;S) ∈ U{i}] {
  auto; *{ unfold <spreidingswet neighborhoods>; reduce; auto }
}.

Resource wf += { wf-lemma <spreidingswet-wf> }.

Operator spreiding : (0).
[spreiding(F)] =def= [{S:|F ♮| -> U{i} | spreidingswet(F; S)}].

Theorem spreiding-wf : [{F:container{i}} spreiding(F) ∈ U{i'}] {
  auto; unfold <spreiding neighborhoods>; reduce; auto;
  [ elim #1 , cum @i ];
  auto; unfold <neighborhoods>; reduce; auto
}.

Resource wf += { wf-lemma <spreiding-wf> }.

Operator universal-spread : ().
[universal-spread] =def= [lam(_.unit)].

Theorem universal-spread-pre-wf : [{F:container{i}} universal-spread ∈ |F ♮| -> U{i}] {
  auto; unfold <universal-spread neighborhoods>; auto;
  elim #1; reduce; auto
}.

Resource wf += { wf-lemma <universal-spread-pre-wf> }.

Theorem universal-spread-wf : [{F:container{i}} (s:|F|) universal-spread ∈ spreiding(F)] {
  unfold <spreiding>; auto; aux { elim #1; reduce; auto };
  eq-cd @i; ?{ !{ auto } };
  unfold <spreidingswet>; auto;
  unfold <neighborhoods>; reduce; auto;
  unfold <universal-spread>; reduce; auto;
  aux { elim #3; reduce; auto; elim #1; reduce; auto };
  focus 0 #{ intro #0; auto };
  intro @i; auto;
  cut-lemma <prefixes-wf>;
  elim #5 [F]; auto;
  unfold <neighborhoods member>; reduce;
  bhyp #6; auto
}.

Resource wf += { wf-lemma <universal-spread-wf> }.
