||| This is a proof that U{i} ∈ U{i} is a contradiction in JonPRL.
||| Proving this follows the reasoning from Russell's paradox: we
||| construct a type which contains all types that don't contain themselves
||| and show that *it* both is and isn't a member.
|||
||| The well-formedness conditions in this proof are absolutely
||| killer and lead to most of the bloat in the proofs.

Tactic impredicativity-wf-tac {
  unfold <member>; eq-base-tac;
  eq-cd; ?{@{[|- =(_; _; base)] => auto}};
  eq-cd @i'; ?{break-plus}; reduce; auto
}.

Theorem u-in-u-wf : [(U{i} ∈ U{i}) ∈ U{i'}] {
  impredicativity-wf-tac
}.

Operator bisect : (0;0).
Infix -> 8 "∩" := bisect.
[A ∩ B] =def= [{b:unit + unit} decide(b; _.A; _.B)].

Theorem bisect-wf : [{A:U{i}} {B:U{i}} A ∩ B ∈ U{i}] {
  unfold <bisect>; auto;
  elim #3; reduce; auto
}.

Resource wf += { wf-lemma <bisect-wf> }.

Theorem eq-wf-base : [{A:U{i}} {a:base} {b:base} =(a; b; A) ∈ U{i}] {
  auto 0; aux { auto };

  eq-base-tac; unfold <snd>; reduce;
  @{ [|- =(m; m; image(_; _))] =>
      csubst [m ~ (lam(p.snd(p)) <inr(<>), m>)]; unfold <snd>;
      aux { reduce; auto };
      auto; reduce; auto;
      elim #4; reduce; auto
   }
}.

Tactic dest-bisect {
  @{ [T : {b:unit + unit} decide(b; _.A; _.B) |- =(T; T; A)] =>
       wf-lemma <eq-wf-base>; auto;
       elim <T> [inl(<>)];
       main { elim <T> [inr(<>)] };
       aux { auto }; reduce; auto;
       @{ [H : =(m; n; S) |- =(n; n; S)] =>
           hyp-subst <- <H> [h.=(h; h; _)]; auto
        }
   }
}.


Operator Russell : ().
[Russell] =def= [{x : U{i} ∩ base | ¬ (x ∈ x)}].

Theorem Russell-wf : [Russell ∈ U{i'}] {
  unfold <Russell bisect not implies>;
  auto 0; eq-cd;
  eq-cd; ?{ !{ auto } };
  focus 0 #{
    elim #1; reduce; auto
  };

  cum @i; dest-bisect
}.

Resource wf += { wf-lemma <Russell-wf> }.

Theorem Russell-in-base : [Russell ∈ base] {
  unfold <Russell bisect not implies>;
  auto
}.

Resource wf += { wf-lemma <Russell-in-base> }.

Theorem russell-property : [¬ (Russell ∈ Russell)] {
  unfold <not implies>; intro @i';
  aux {
    assert [{A:U{i'}} {a:base} {b:base} =(a; b; A) ∈ U{i'}] <eq-wf-base>;
    aux { lemma <eq-wf-base> };
    unfold <member>; bhyp <eq-wf-base>;
    auto
  };

  assert [(R:Russell) * R ~ Russell];
  aux { intro [Russell] @i; auto };
  elim #2;
  unfold <Russell>;
  elim #3;

  assert [¬ ({x:U{i} ∩ base | ¬ (x ∈ x)} ∈ {x:U{i} ∩ base | ¬ (x ∈ x)})];
  aux {
    chyp-subst <- #6;
    unfold <not implies>;
    intro @i;
    aux { unfold <member bisect>; dest-bisect };
    contradiction
  };

  contradiction
}.


Theorem type-not-in-type : [¬ (U{i} ∈ U{i})] {
  unfold <not implies>;
  intro @i'; aux { wf-lemma <u-in-u-wf> };

  assert [Russell ∈ U{i}] <russell-wf>;
  aux {
    unfold <member Russell not implies>;
    auto; unfold <member bisect>;
    dest-bisect
  };

  cut-lemma <russell-property>;

  assert [Russell ∈ Russell] <russell-wf>;
  main { contradiction };

  unfold <member Russell>; eq-cd @i;
  aux {
    unfold <member not implies bisect>;
    eq-cd; ?{ !{ auto } };
    dest-bisect
  };

  focus 0 #{
    unfold <bisect>; auto; elim #4;
    reduce; auto
  };

  unfold <not implies>; auto;
  intro @i';
  aux {
    unfold <member bisect>; prune { eq-cd };
    [ eq-cd; eq-cd; ?{ !{ auto } };
      [ elim #4; reduce; auto
      , cum @i; dest-bisect
      ];
    , eq-cd @i;
      aux {
        unfold <member>;
        eq-cd @i; ?{ !{ auto } };
        dest-bisect
      }; auto;
      elim #4; reduce; auto
    ];
  };

  unfold <member>;
  contradiction
}.
