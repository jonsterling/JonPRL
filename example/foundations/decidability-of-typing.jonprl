||| This demonstrates that there is no decidable algorithm so
||| that we can compute whether a closed term [a] belongs to some
||| type [A].
|||
||| This is proven by straightforward reduction to the halting problem,
||| we show that such an algorithm can decide if [a] is in
||| {m : base | has-value(m)}. From there it's just inversion and then
||| referencing our previous lemma [halting-problem-undecidable].

Theorem member-wf : [(a : base)(A : U{i}) member(member(a; A); U{i'})] {
  auto 0; aux {auto}; eq-eq-base; auto;

  bunion-eq-right; unfold <bunion>; eq-cd; auto;
  reduce; auto; break-plus; reduce; auto
}.

Resource wf += {wf-lemma <member-wf>}.

Theorem typing-undecidable : [¬ ((A : U{i})(a : base) (a ∈ A) decidable)] {
  unfold <not implies dec>; intro;
  aux {
    unfold <not implies member>; eq-cd; eq-cd;
    eq-cd; ?{wf-lemma <member-wf>}; ?{!{auto}};
    eq-cd; ?{wf-lemma <member-wf>}; auto
  };

  elim #1 [{m : base | m ⇓}]; auto;

  assert [(m:base) dec(has-value(m))];
  aux {
    auto; elim #2 [m]; auto; elim #5;

    focus 0 #{
      assert [(x : {m : base | m ⇓}) * x ~ m];
      aux {intro [m]; auto};
      elim #8; chyp-subst ← #10 [h. has-value(h) + not(has-value(h))];
      elim #9; intro #0; unfold <not implies>; auto;
    };

    assert [(x : {m : base | not(m ⇓)}) * x ~ m];
    aux {
      unfold <not implies>; intro [m]; auto;
      assert [member(m; {m : base | m ⇓})]; aux {auto};
      elim #6 [H]; auto
    };
    elim #8; chyp-subst ← #10 [h. has-value(h) + not(has-value(h))];
    elim #9; intro #1; unfold <not implies>; auto;
    elim #11 [x']; auto
  };
  cut-lemma <halting-problem-undecidable>; unfold <not implies>;
  elim #5 [H]; auto
}.
