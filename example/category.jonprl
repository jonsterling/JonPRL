Infix 2 "∈" := member.

Operator RawCat : ().
Operator obj : (0).
Operator hom : (0;0;0).
Operator idn : (0;0).
Operator cmp : (0;0;0;0;0;0).

[RawCat] =def= [
  (Obj:U{i})
  * (Hom : Obj -> Obj -> U{i})
  * (Idn : (A:Obj) Hom A A)
  * (Cmp : (A:Obj) (B:Obj) (C:Obj) Hom B C -> Hom A B -> Hom A C)
  * unit
].

[obj(C)] =def= [spread(C; x.y.x)].
[hom(C;A;B)] =def= [spread(spread(C; x.y.y); x.y.x) A B].
[idn(C;A)] =def= [spread(spread(spread(C; x.y.y); x.y.y); x.y.x) A].
[cmp(C;X;Y;Z;f;g)] =def= [spread(spread(spread(spread(C; x.y.y); x.y.y); x.y.y); x.y.x) X Y Z f g].

Tactic rawcat-unfold {
  unfold <RawCat obj hom idn cmp unit>.
}.

Tactic autoR {
  reduce; *{auto; reduce}.
}.

Theorem RawCat-wf : [member(RawCat; U{i'})] {
  rawcat-unfold; auto.
}.

Resource wf += { wf-lemma <RawCat-wf> }.

Resource intro += {
  @{ [|- {RC : RawCat} P] => intro @i'
   | [|- {A : obj(C)} P] => intro @i
   }
}.

Theorem obj-wf : [{RC:RawCat} member(obj(RC); U{i})] {
  auto; unfold <obj RawCat>; auto
}.

Resource wf += { wf-lemma <obj-wf> }.

Theorem hom-wf : [
  {RC:RawCat} {A:obj(RC)} {B:obj(RC)} member(hom(RC;A;B); U{i})
] {
  auto;
  unfold <RawCat hom obj>;
  auto; reduce; auto
}.

Resource wf += { wf-lemma <hom-wf> }.

Theorem idn-wf : [
  {RC:RawCat} {A:obj(RC)} member(idn(RC; A); hom(RC; A; A))
] {
  auto; unfold <RawCat idn obj hom>;
  auto; reduce; auto
}.

Resource wf += { wf-lemma <idn-wf> }.

Theorem cmp-wf : [
  {RC:RawCat}
  {X:obj(RC)}
  {Y:obj(RC)}
  {Z:obj(RC)}
  {f:hom(RC; Y; Z)}
  {g:hom(RC; X; Y)}
    member(cmp(RC;X;Y;Z;f;g); hom(RC; X;Z))
] {
  auto; unfold <RawCat cmp hom obj>;
  auto; reduce; auto
}.

Resource wf += { wf-lemma <cmp-wf> }.

Operator LeftIdentity : (0).
[LeftIdentity(C)] =def= [{A:obj(C)} {B:obj(C)} {f:hom(C;A;B)} =(cmp(C;A;B;B; idn(C;B); f); f; hom(C;A;B))].

Operator RightIdentity : (0).
[RightIdentity(C)] =def= [{A:obj(C)} {B:obj(C)} {f:hom(C;A;B)} =(cmp(C;A;A;B; f; idn(C;A)); f; hom(C;A;B))].

Operator CmpAssoc : (0).
[CmpAssoc(C)] =def= [
  {W:obj(C)} {X:obj(C)} {Y:obj(C)} {Z:obj(C)}
  {f:hom(C;W;X)}
  {g:hom(C;X;Y)}
  {h:hom(C;Y;Z)}
    =(cmp(C;W;X;Z; cmp(C;X;Y;Z; h;g); f);
      cmp(C;W;Y;Z; h; cmp(C;W;X;Y; g;f));
      hom(C;W;Z))
].

Theorem LeftIdentity-wf : [{RC:RawCat} member(LeftIdentity(RC); U{i})] {
  unfold <LeftIdentity>; auto;
}.

Theorem RightIdentity-wf : [{RC:RawCat} member(RightIdentity(RC); U{i})] {
  unfold <RightIdentity>; auto
}.

Theorem CmpAssoc-wf : [{RC:RawCat} member(CmpAssoc(RC); U{i})] {
  unfold <CmpAssoc>; auto
}.

Operator LawCat : (0).
[LawCat(RC)] =def= [LeftIdentity(RC) * RightIdentity(RC) * CmpAssoc(RC)].

Tactic lawcat-unfold {
  unfold <LeftIdentity RightIdentity CmpAssoc LawCat>;
  rawcat-unfold.
}.

Resource wf += { wf-lemma <LeftIdentity-wf> }.
Resource wf += { wf-lemma <RightIdentity-wf> }.
Resource wf += { wf-lemma <CmpAssoc-wf> }.

Theorem LawCat-wf : [{RC:RawCat} member(LawCat(RC); U{i})] {
  unfold <LawCat>; auto
}.

Resource wf += { wf-lemma <LawCat-wf> }.

Operator Cat : ().
[Cat] =def= [{C : RawCat | LawCat(C)}].

Tactic cat-unfold {
  unfold <Cat>; lawcat-unfold.
}.

Theorem Cat-wf : [member(Cat; U{i'})] {
  unfold <Cat>; auto; cum @i; auto
}.

Resource wf += { wf-lemma <Cat-wf> }.


Resource intro += {
  @{ [|- {RC : Cat} P] => intro @i'
   }
}.

Operator exists-unique : (0;1).
[exists-unique(A; x.C[x])] =def= [
  {x:A | C[x] * {y:A} C[y] => =(x; y; A)}
].

Theorem exists-unique-wf : [{A:U{i}} {B:A -> U{i}} exists-unique(A; x.B x) ∈ U{i}] {
  unfold <exists-unique>; auto
}.

Resource wf += { wf-lemma <exists-unique-wf> }.

Operator is-pullback : (0;0;0;0;0;0;0).
[is-pullback(C; a; b; c; p; f; g)] =def= [
  (pi1 : hom(C; p; a))
  * (pi2 : hom(C; p; b))
  * (comm : =(cmp(C; p; b; c; g; pi2); cmp(C; p; a; c; f; pi1); hom(C; p; c)))
  * {q : obj(C)}
     (h1 : hom(C; q; a))
     (h2 : hom(C; q; b))
     (comm' : =(cmp(C; q; b; c; g; h2); cmp(C; q; a; c; f; h1); hom(C; q; c)))
       exists-unique(hom(C; q; p); u.
         =(cmp(C; q; p; b; pi2; u); h2; hom(C; q; b))
         * =(cmp(C; q; p; a; pi1; u); h1; hom(C; q; a)))
].

Resource wf += {
  @{ [C:Cat |- =(C; C; RawCat)] => unfold <Cat>; elim <C>; auto
   }
}.

Theorem is-pullback-wf : [{C:Cat} {a:obj(C)} {b:obj(C)} {c:obj(C)} {p:obj(C)} {f:hom(C; a; c)} {g:hom(C; b; c)} is-pullback(C; a; b; c; p; f; g) ∈ U{i}] {
  unfold <is-pullback>; auto;
  *{ intro @i }; auto;
  unfold <exists-unique>; auto;
}.
