Operator RawCat : ().
Operator obj : (0).
Operator hom : (0;0;0).
Operator idn : (0;0).
Operator cmp : (0;0;0;0;0;0).

[RawCat] =def= [
  (Obj:U{i})
  * (Hom : Obj -> Obj -> U{i})
  * (Idn : (A:Obj) Hom A A)
  * (Cmp : (A:Obj) (B:Obj) (C:Obj) Hom B C -> Hom A B -> Hom A C)
  * unit
].

[obj(C)] =def= [spread(C; x.y.x)].
[hom(C;A;B)] =def= [spread(spread(C; x.y.y); x.y.x) A B].
[idn(C;A)] =def= [spread(spread(spread(C; x.y.y); x.y.y); x.y.x) A].
[cmp(C;X;Y;Z;f;g)] =def= [spread(spread(spread(spread(C; x.y.y); x.y.y); x.y.y); x.y.x) X Y Z f g].

Tactic rawcat_unfold {
  unfold <RawCat obj hom idn cmp>.
}.

Tactic autoR {
  reduce; *{auto; reduce}.
}.

Theorem RawCat_wf : [member(RawCat; U{i'})] {
  rawcat_unfold; auto.
}.


Theorem obj_wf : [{RC:RawCat} member(obj(RC); U{i})] {
  rawcat_unfold; auto.
}.

Theorem hom_wf : [
  {RC:RawCat} {A:obj(RC)} {B:obj(RC)} member(hom(RC;A;B); U{i})
] {
  rawcat_unfold; autoR.
}.

Theorem idn_wf : [
  {RC:RawCat} {A:obj(RC)} member(idn(RC; A); hom(RC; A; A))
] {
  rawcat_unfold; autoR.
}.

Theorem cmp_wf : [
  {RC:RawCat}
  {X:obj(RC)}
  {Y:obj(RC)}
  {Z:obj(RC)}
  {f:hom(RC; Y; Z)}
  {g:hom(RC; X; Y)}
    member(cmp(RC;X;Y;Z;f;g); hom(RC; X;Z))
] {
  rawcat_unfold; autoR.
}.

Operator LeftIdentity : (0).
[LeftIdentity(C)] =def= [{A:obj(C)} {B:obj(C)} {f:hom(C;A;B)} =(cmp(C;A;B;B; idn(C;B); f); f; hom(C;A;B))].

Operator RightIdentity : (0).
[RightIdentity(C)] =def= [{A:obj(C)} {B:obj(C)} {f:hom(C;A;B)} =(cmp(C;A;A;B; f; idn(C;A)); f; hom(C;A;B))].

Operator CmpAssoc : (0).
[CmpAssoc(C)] =def= [
  {W:obj(C)} {X:obj(C)} {Y:obj(C)} {Z:obj(C)}
  {f:hom(C;W;X)}
  {g:hom(C;X;Y)}
  {h:hom(C;Y;Z)}
    =(cmp(C;W;X;Z; cmp(C;X;Y;Z; h;g); f);
      cmp(C;W;Y;Z; h; cmp(C;W;X;Y; g;f));
      hom(C;W;Z))
].

Tactic isect-RawCat {
  @{ [|- {RC : RawCat} P] => intro @i'; focus 1 #{ lemma <RawCat_wf> }
   }
}.

Tactic basic-wf {
  cut-lemma <obj_wf>;
  cut-lemma <hom_wf>;
  cut-lemma <cmp_wf>;
  auto; ?{(bhyp <obj_wf> | bhyp <hom_wf> | bhyp <cmp_wf>); auto};
}.

Theorem LeftIdentity_wf : [{RC:RawCat} member(LeftIdentity(RC); U{i})] {
  unfold <LeftIdentity idn>; isect-RawCat; basic-wf;
  rawcat_unfold; autoR
}.

Theorem RightIdentity_wf : [{RC:RawCat} member(RightIdentity(RC); U{i})] {
  unfold <RightIdentity>; isect-RawCat; basic-wf;
  rawcat_unfold; autoR
}.

Theorem CmpAssoc_wf : [{RC:RawCat} member(CmpAssoc(RC); U{i})] {
  unfold <CmpAssoc>; isect-RawCat; basic-wf;
  rawcat_unfold; autoR
}.

Operator LawCat : (0).
[LawCat(RC)] =def= [LeftIdentity(RC) * RightIdentity(RC) * CmpAssoc(RC)].

Tactic lawcat_unfold {
  unfold <LeftIdentity RightIdentity CmpAssoc LawCat>;
  rawcat_unfold.
}.

Tactic basic-wf' {
  basic-wf;
  cut-lemma <LeftIdentity_wf>;
  cut-lemma <RightIdentity_wf>;
  cut-lemma <CmpAssoc_wf>;
  unfold <member>;
  auto; ?{(bhyp <LeftIdentity_wf> | bhyp <RightIdentity_wf> | bhyp <CmpAssoc_wf>); auto};
}.

Theorem LawCat_wf : [{RC:RawCat} member(LawCat(RC); U{i})] {
  unfold <LawCat>; isect-RawCat; basic-wf'
}.

Operator Cat : ().
[Cat] =def= [{C : RawCat | LawCat(C)}].

Tactic cat_unfold {
  unfold <Cat>; lawcat_unfold.
}.

Theorem Cat-wf : [member(Cat; U{i'})] {
  unfold <Cat>; auto;
  cut-lemma <RawCat_wf>; unfold <member>; auto;
  cum @i; cut-lemma <LawCat_wf>; unfold <member>; bhyp <LawCat_wf>;
  auto
}.

Theorem InitialRawCat : [RawCat] {
  unfold <RawCat>;
  intro [void]; auto;
  intro [lam(A. lam(B. void))]; auto
}.

Theorem InitialCat : [Cat] {
  unfold <Cat>;
  intro [InitialRawCat] @i;
  unfold <InitialRawCat>;
  [id, id, cut-lemma <LawCat_wf>; elim #2 [C]];
  *{lawcat_unfold; auto; reduce}
}.

Theorem TerminalRawCat : [RawCat] {
  unfold <RawCat>;
  intro [unit]; autoR;
  intro [lam(A. lam(B. unit))]; autoR;
}.

Tactic unit-eta {
  @{ [f : unit |- =(f; <>; unit)] => elim <f>; eq-cd }
}.

Theorem TerminalCat : [Cat] {
  unfold <Cat>;
  intro [TerminalRawCat] <C> @i; unfold <TerminalRawCat>;
  focus 2 #{
    cut-lemma <LawCat_wf>; bhyp <LawCat_wf>; auto
  };

  *{lawcat_unfold; auto; reduce};
  symmetry; unit-eta
}.
