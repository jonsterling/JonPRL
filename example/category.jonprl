Infix 2 "∈" := member.

Operator raw-category : ().
Operator obj : (0).
Operator hom : (0;0;0).
Operator idn : (0;0).
Operator cmp : (0;0;0;0;0;0).

[raw-category] =def= [
  (Obj:U{i})
  * (Hom : Obj -> Obj -> U{i})
  * (Idn : (A:Obj) Hom A A)
  * (Cmp : (A:Obj) (B:Obj) (C:Obj) Hom B C -> Hom A B -> Hom A C)
  * unit
].

[obj(C)] =def= [spread(C; x.y.x)].
[hom(C;A;B)] =def= [spread(spread(C; x.y.y); x.y.x) A B].
[idn(C;A)] =def= [spread(spread(spread(C; x.y.y); x.y.y); x.y.x) A].
[cmp(C;X;Y;Z;f;g)] =def= [spread(spread(spread(spread(C; x.y.y); x.y.y); x.y.y); x.y.x) X Y Z f g].

Theorem raw-category-wf : [member(raw-category; U{i'})] {
  unfold <raw-category obj hom idn cmp unit>; auto
}.

Resource wf += { wf-lemma <raw-category-wf> }.

Resource intro += {
  @{ [|- {RC : raw-category} P] => intro @i'
   | [|- {A : obj(C)} P] => intro @i
   }
}.

Theorem obj-wf : [{RC:raw-category} member(obj(RC); U{i})] {
  auto; unfold <obj raw-category>; auto
}.

Resource wf += { wf-lemma <obj-wf> }.

Theorem hom-wf : [
  {RC:raw-category} {A:obj(RC)} {B:obj(RC)} member(hom(RC;A;B); U{i})
] {
  auto;
  unfold <raw-category hom obj>;
  auto; reduce; auto
}.

Resource wf += { wf-lemma <hom-wf> }.

Theorem idn-wf : [
  {RC:raw-category} {A:obj(RC)} member(idn(RC; A); hom(RC; A; A))
] {
  auto; unfold <raw-category idn obj hom>;
  auto; reduce; auto
}.

Resource wf += { wf-lemma <idn-wf> }.

Theorem cmp-wf : [
  {RC:raw-category}
  {X:obj(RC)}
  {Y:obj(RC)}
  {Z:obj(RC)}
  {f:hom(RC; Y; Z)}
  {g:hom(RC; X; Y)}
    member(cmp(RC;X;Y;Z;f;g); hom(RC; X;Z))
] {
  auto; unfold <raw-category cmp hom obj>;
  auto; reduce; auto
}.

Resource wf += { wf-lemma <cmp-wf> }.

Operator left-identity : (0).
[left-identity(C)] =def= [{A:obj(C)} {B:obj(C)} {f:hom(C;A;B)} =(cmp(C;A;B;B; idn(C;B); f); f; hom(C;A;B))].

Operator right-identity : (0).
[right-identity(C)] =def= [{A:obj(C)} {B:obj(C)} {f:hom(C;A;B)} =(cmp(C;A;A;B; f; idn(C;A)); f; hom(C;A;B))].

Operator cmp-assoc : (0).
[cmp-assoc(C)] =def= [
  {W:obj(C)} {X:obj(C)} {Y:obj(C)} {Z:obj(C)}
  {f:hom(C;W;X)}
  {g:hom(C;X;Y)}
  {h:hom(C;Y;Z)}
    =(cmp(C;W;X;Z; cmp(C;X;Y;Z; h;g); f);
      cmp(C;W;Y;Z; h; cmp(C;W;X;Y; g;f));
      hom(C;W;Z))
].

Theorem left-identity-wf : [{RC:raw-category} member(left-identity(RC); U{i})] {
  unfold <left-identity>; auto;
}.

Theorem right-identity-wf : [{RC:raw-category} member(right-identity(RC); U{i})] {
  unfold <right-identity>; auto
}.

Theorem cmp-assoc-wf : [{RC:raw-category} member(cmp-assoc(RC); U{i})] {
  unfold <cmp-assoc>; auto
}.

Operator category-laws : (0).
[category-laws(RC)] =def= [left-identity(RC) * right-identity(RC) * cmp-assoc(RC)].

Resource wf += { wf-lemma <left-identity-wf> }.
Resource wf += { wf-lemma <right-identity-wf> }.
Resource wf += { wf-lemma <cmp-assoc-wf> }.

Theorem category-laws-wf : [{RC:raw-category} member(category-laws(RC); U{i})] {
  unfold <category-laws>; auto
}.

Resource wf += { wf-lemma <category-laws-wf> }.

Operator category : ().
[category] =def= [{C : raw-category | category-laws(C)}].

Theorem category-wf : [member(category; U{i'})] {
  unfold <category>; auto; cum @i; auto
}.

Resource wf += { wf-lemma <category-wf> }.


Resource intro += {
  @{ [|- {RC : category} P] => intro @i'
   }
}.

Operator exists-unique : (0;1).
[exists-unique(A; x.C[x])] =def= [
  {x:A | C[x] * {y:A} C[y] => =(x; y; A)}
].

Theorem exists-unique-wf : [{A:U{i}} {B:A -> U{i}} exists-unique(A; x.B x) ∈ U{i}] {
  unfold <exists-unique>; auto
}.

Operator is-pullback : (0;0;0;0;0;0;0).
[is-pullback(C; a; b; c; p; f; g)] =def= [
  (pi1 : hom(C; p; a))
  * (pi2 : hom(C; p; b))
  * (comm : =(cmp(C; p; b; c; g; pi2); cmp(C; p; a; c; f; pi1); hom(C; p; c)))
  * {q : obj(C)}
     (h1 : hom(C; q; a))
     (h2 : hom(C; q; b))
     (comm' : =(cmp(C; q; b; c; g; h2); cmp(C; q; a; c; f; h1); hom(C; q; c)))
       exists-unique(hom(C; q; p); u.
         =(cmp(C; q; p; b; pi2; u); h2; hom(C; q; b))
         * =(cmp(C; q; p; a; pi1; u); h1; hom(C; q; a)))
].

Resource wf += {
  @{ [C:category |- =(C; C; raw-category)] => unfold <category>; elim <C>; auto
   }
}.

Theorem is-pullback-wf : [{C:category} {a:obj(C)} {b:obj(C)} {c:obj(C)} {p:obj(C)} {f:hom(C; a; c)} {g:hom(C; b; c)} is-pullback(C; a; b; c; p; f; g) ∈ U{i}] {
  unfold <is-pullback>; auto;
  *{ intro @i }; auto;
  unfold <exists-unique>; auto;
}.

Resource wf += { wf-lemma <is-pullback-wf> }.

Operator has-pullbacks : (0).
[has-pullbacks(C)] =def= [
  (a:obj(C)) (b:obj(C)) (c:obj(C)) (f:hom(C; a; c)) (g:hom(C; b; c))
    (p:obj(C)) * is-pullback(C; a; b; c; p; f; g)
].

Theorem has-pullbacks-wf : [{C:category} has-pullbacks(C) ∈ U{i}] {
  unfold <has-pullbacks>; auto
}.

Resource wf += { wf-lemma <has-pullbacks-wf> }.

Operator category-with-pullbacks : ().
[category-with-pullbacks] =def= [
  (C : category) * has-pullbacks(C)
].

Theorem category-with-pullbacks-wf : [category-with-pullbacks ∈ U{i'}] {
  unfold <category-with-pullbacks>; auto;
  cum @i; auto
}.

Resource wf += { wf-lemma <category-with-pullbacks-wf> }.

Operator is-isomorphism : (0;0;0;0).
[is-isomorphism(C; a; b; f)] =def= [
  {g : hom(C; b; a) |
     =(cmp(C; a; b; a; g; f); idn(C; a); hom(C; a; a))
     * =(cmp(C; b; a; b; f; g); idn(C; b); hom(C; b; b))
  }
].

Theorem is-isomorphism-wf : [{C:category} {a:obj(C)} {b:obj(C)} {f:hom(C; a; b)} is-isomorphism(C; a; b; f) ∈ U{i}] {
  unfold <is-isomorphism>; auto;
  intro @i; auto
}.

Resource wf += { wf-lemma <is-isomorphism-wf> }.

Operator isomorphism : (0;0;0).
[isomorphism(C; a; b)] =def= [
  {f : hom(C; a; b) | is-isomorphism(C; a; b; f)}
].

Theorem isomorphism-wf : [{C:category} {a:obj(C)} {b:obj(C)} isomorphism(C; a; b) ∈ U{i}] {
  unfold <isomorphism>; auto
}.

Resource wf += { wf-lemma <isomorphism-wf> }.

Resource wf += {
  @{ [f:isomorphism(C; a; b) |- =(f; f; hom(C; a; b))] => unfold <isomorphism>; elim <f>; auto
  }
}.


Operator family : (0).
[family(A)] =def= [(I:U{i}) * I -> A].

Theorem family-wf : [{I:U{i}} family(I) ∈ U{i'}] {
  unfold <family>; auto
}.

Resource wf += { wf-lemma <family-wf> }.

Operator covering-family : (0;0).
[covering-family(C; d)] =def= [
  family((c : obj(C)) * hom(C; c; d))
].

Theorem covering-family-wf : [{C:category} {d:obj(C)} covering-family(C; d) ∈ U{i'}] {
  unfold <covering-family>; auto
}.

Resource wf += { wf-lemma <covering-family-wf> }.

Operator covering : (0).
[covering(C)] =def= [
  (d:obj(C)) (F:covering-family(C; d)) U{i}
].

Theorem covering-wf : [{C:category} covering(C) ∈ U{i'}] {
  unfold <covering>; auto;
  cum @i; auto
}.

Resource wf += { wf-lemma <covering-wf> }.


Operator isomorphisms-cover : (0;0).
[isomorphisms-cover(C; K)] =def= [
  (a:obj(C)) (b:obj(C)) (f:isomorphism(C; a; b))
    K b <unit, lam(_.<a, f>)>
].

Theorem isomorphisms-cover-wf : [{C:category} {K:covering(C)} isomorphisms-cover(C; K) ∈ U{i}] {
  unfold <isomorphisms-cover>; auto; intro @i'; auto;
  unfold <covering covering-family family>; auto;
  ?{ cum @i; auto };
  eq-cd @i; auto
}.

Resource wf += { wf-lemma <isomorphisms-cover-wf> }.

Operator stability : (0;0).
[stability(C; K)] =def= [
  (c:obj(C)) (d:obj(C)) (F:covering-family(C; d)) (g:hom(C; c; d))
    K d F -> K c "TODO"
].

Operator local-character : (0;0).


||| A Grothendieck pretopology
Operator pretopology : (0).
[pretopology(C)] =def= [
  spread(C; C.pb.
    (K : covering(C))
      * isomorphisms-cover(C; K)
      * stability(C; K)
      * local-character(C; K)
  )
].
