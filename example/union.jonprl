Infix 20 "∈" := member.
Infix 100 "~" := ceq.

Operator snd : ().
[snd] =def= [lam(x. spread(x; u.v.v))].

Operator union : (0;1).
[union(A; x.B[x])] =def= [image((x : A) * B[x]; snd)].

Theorem union-wf : [
  {A : U{i}} {B : A -> U{i}} union(A; x.B x) ∈ U{i}
] {
  unfold <union snd>; auto
}.

Operator top : ().
[top] =def= [void => void].

Operator rec : (1).
[rec(x.F[x])] =def= [union(nat; n. natrec(n; void; _.x. F[x]))].

Operator NAT : ().
[NAT] =def= [rec(X. unit + X)].

Operator ZE : ().
[ZE] =def= [inl(<>)].

Operator SU : (0).
[SU(N)] =def= [inr(N)].

Theorem NAT-wf : [NAT ∈ U{i}] {
  unfold <NAT rec union top>; auto
}.

Theorem ZE-wf : [ZE ∈ NAT] {
  assert [ZE ~ (snd <succ(zero), ZE>)] <H>;
  focus 0 #{
    unfold <ZE snd>; reduce; auto
  };

  chyp-subst -> <H> [h. h ∈ NAT]; thin <H>;
  unfold <NAT ZE rec union top>; auto;
  reduce; auto
}.

Operator nat-of : (0).
[nat-of(N)] =def= [fix(lam(F.decide(N; l.zero; r.succ(F r))))].

Tactic isect-NAT {
  @{ [|- {n:NAT} _] => intro @i; focus 1 #{ lemma <NAT-wf> }}
}.

Tactic NAT-induction {
  @{ [n:NAT |- _] =>
     unfold <NAT rec union>; elim <n> <w>; elim <w> <s, t>; elim <s>
  }
}.

Tactic steps {
  *{ (!{ step; auto} | step; auto) }
}.

Theorem nat-of-wf : [{n:NAT} nat-of(n) ∈ nat] {
  isect-NAT; NAT-induction;
  unfold <snd>; reduce; auto
}.

Theorem SU-wf : [{n:NAT} SU(n) ∈ NAT] {
  isect-NAT;

  assert [SU(n) ~ (snd <succ(nat-of(n)), SU(n)>)] <H>;
  focus 0 #{
    unfold <SU nat-of snd>; csymmetry; steps
  };

  chyp-subst -> <H> [h.h ∈ NAT];
  NAT-induction;
  unfold <snd>; reduce; auto
}.
